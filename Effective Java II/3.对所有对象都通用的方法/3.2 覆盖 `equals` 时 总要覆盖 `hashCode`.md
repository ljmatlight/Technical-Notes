
# 第三章 对所有对象都通用的方法

## 3.2 覆盖 `equals` 时 总要覆盖 `hashCode`

> 在每个覆盖实现 `equals` 方法的类中，也必须覆盖实现 `hashCode` 方法。
> 如果不这样做的话，就违反了 `Object.hashCode` 的通用约定，
> 从而导致该类无法结合所有基于散列的集合一起正常工作。
> 这样的集合包括： `HashMap`，`HashSet` 和 `HashTable`。

### `Object.hashCode` 的通用约定:

- 只要对象的 `equals` 方法的比较操作所用到的信息没有被修改，那么 多次执行应用程序，可以是不相同的，但同一次应用程序的执行期间，必定是相同的
- 如果两个对象根据 `equals(Object)` 方法比较是相等的，那么这个两个对象的 `hashCode` 值也是相等的。
- 如果两个对象根据 `equals(Object)` 方法比较是不相等的，那么这两个对象的 `hashCode` 值有可能相等，也有可能不相等。

也就是我们常说的: 
条件A： `equals` 相等 
条件B： `hashCode` 相等
那么： A => B 

### 覆盖 `hashCode` 方法最佳实践

- 使用 `IDE` 工具自动生成 `hashCode` 方法
- 如果一个类是不可变的，并且计算散列码的开销也比较大，就应该考虑把散列码缓存在对象内部，而不是每次请求的时候都重新计算散列码。如果觉得这种类型的大多数对象会被用做散列键（`hash keys`）,就应该在创建实例的时候计算散列码。或者使用懒加载的方式进行初始化操作，在第一次调用时初始化。